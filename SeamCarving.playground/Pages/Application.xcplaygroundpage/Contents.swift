/*:
 # Application
 
 Now that we have figured out how to remove one seam from the image, we can repeat that process to remove multiple.
 
 ## Implementation
 
 The simplest method of doing so would be just looping the entirety of what removes a single seam. That would be implemented as:
 */

import AppKit

func _carveImage(_ image: CGImage, width: Int) -> CGImage {
    var carvedImage = image
    
    let widthDiff = image.width - width
    for _ in 0..<widthDiff {
        // get sobeled image
        let sobeledImage = sobel(carvedImage)
        let sobeledBuffer  = sobeledImage.planarBuffer
        
        // get sums from sobel
        let (sums, dirs) = intensitySums(buffer: sobeledBuffer)
        sobeledBuffer.free()
        
        // find seam
        let seam = findSeam(intensitySum: sums, directions: dirs)
        var imageMatrix = carvedImage.argbBuffer.argb8ToMatrix()
        
        // apply seam
        removeSeam(seam, from: &imageMatrix)
        
        // turn matrix into image so Sobel filter can be reapplied
        carvedImage = CGImage.argbFromMatrix(imageMatrix)
    }
    
    // reassemble
    let newSize = NSSize(width: carvedImage.width, height: carvedImage.height)
    
    return NSImage(cgImage: carvedImage, size: newSize).cgImage
}

//: Now let's use that to shrink our image a noticeable amount

// Decrease the size of the image to keep the playground running quickly
let maxSize = NSSize(width: 350, height: 350)
let image = NSImage(named: "pom")!.constrained(to: maxSize).cgImage

// Use our function
let carved = carveImage(image, width: 310)

//: We can now compare our carved image to the original

image
carved

/*:
 ## Potential Optimization
 
 The two components of each seam removal which take up the most time are the summing function and the Sobel filter. Over my time working on this project I have highly optimized the summing function, gradually bringing it down from over 100ms a pass to 3ms.
 
 That makes the next obvious target the Sobel filter. Because of running on the GPU, the Sobel filter is already highly optimized, clocking in at only around 5ms per application. However, there is a method that would greatly reduce the total time spent on the Sobel filter.
 
 Currently the Sobel filter is reapplied every time a row is removed from the image. When there are large gaps between the edges in the image that is not entirely necessary because the edges would not dramatically change between each pass.
 
 The nature of the seam removing function allows for this reuse because its whole point is to dodge pixels of high intensity in the Sobel output. However on visually busier images, removing a seam might create an area of higher edginess than before causing the Sobel output to become meaningfully outdated and ultimately leading to more jarring removals.
 
 That Sobel sharing function can be implemented as below. This utilizes a different summing function which takes in a matrix instead of an image buffer. It is the exact same otherwise (which can be confirmed at `/Sources/Sums.swift`).
 
 */

func _sharedCarveImage(_ image: CGImage, width: Int) -> CGImage {
    let widthDiff = image.width - width
    
    // get sobeled image
    let sobeledImage = sobel(image)
    let sobeledBuffer = sobeledImage.planarBuffer
    
    // get matrix of both
    var imageMatrix = image.argbBuffer.argb8ToMatrix()
    var sobelMatrix = sobeledBuffer.planarToMatrix()
    sobeledBuffer.free()
    
    for _ in 0..<widthDiff {
        // get sums and seam
        let (sums, dirs) = intensitySums(intensities: sobelMatrix)
        let seam = findSeam(intensitySum: sums, directions: dirs)
        
        // apply seam to both sobel and image
        removeSeam(seam, from: &imageMatrix)
        removeSeam(seam, from: &sobelMatrix)
    }
    
    // reassemble
    let carvedImage = CGImage.argbFromMatrix(imageMatrix)
    let newSize = NSSize(width: width, height: image.height)
    
    return NSImage(cgImage: carvedImage, size: newSize).cgImage
}

// Use our new function
let sharedCarve = sharedCarveImage(image, width: 310)

/*:
 As you can see, the results between shared and unique Sobel is nearly identical in this case.
 However, there are some areas where the shared Sobel method resulted in a sloppier image.
 For example, the new boarder between the mountain and the sky is more jarring.
 */

carved
sharedCarve

/*:
 The performance of the shared Sobel method vs the unique Sobel method can be seen on this graph.
 
 ![Total Time](/TotalTime.png)
 
 (All graphs generated by using `os_signpost` and Xcode time profiler to get an average time for many runs. It was then plotted in excel.)
 
 That is quite a notable performance improvement.
 
 However, the tradeoff of quality can be seen with the mountains. The boarder between the mountain and the sky is removable at first because of how the colors are blended, though as it is removed the transition becomes sharper and sharper. The algorithm is never made aware of that development because the sobel is never recalculated.
 
 ## Balancing Optimization with Results
 
 A balance could further be struck by recalculating the Sobel filter every after every so many rows are removed. That should allow the formation of new edger, such as with the mountains, to be caught before they become too much of an issue.
 
 That function could be implemented as follows:
 
 */

func _balancedCarveImage(_ image: CGImage, width: Int, sobelPer: Int) -> CGImage {
    let widthDiff = image.width - width
    
    // apply initial sobel
    let sobeledImage = sobel(image)
    let grayscale = sobeledImage.planarBuffer
    
    // get matrixes of orig and sobel
    var imageMatrix = image.argbBuffer.argb8ToMatrix()
    var sobelMatrix = grayscale.planarToMatrix()
    grayscale.free()
    
    for removalNum in 0..<widthDiff {
        // reapply and replace sobel matrix every sobelPer
        if removalNum % sobelPer == 0 {
            let sobeledImage = sobel(CGImage.argbFromMatrix(imageMatrix))
            let grayscale = sobeledImage.planarBuffer
            sobelMatrix = grayscale.planarToMatrix()
        }
        
        // get sum and seam
        let (sums, dirs) = intensitySums(intensities: sobelMatrix)
        let seam = findSeam(intensitySum: sums, directions: dirs)
        
        // apply seam on image and sobel matrix
        removeSeam(seam, from: &imageMatrix)
        removeSeam(seam, from: &sobelMatrix)
    }
    
    // reassemble
    let carvedImage = CGImage.argbFromMatrix(imageMatrix)
    let newSize = NSSize(width: width, height: image.height)
    
    return NSImage(cgImage: carvedImage, size: newSize).cgImage
}

// Use our new function
let balancedCarve = balancedCarveImage(image, width: 310, sobelPer: 10)

//: As you can see, the results between balanced and unique Sobel is even closer.
//: That can especially be seen by the return to a curvier mountain side.

carved
sharedCarve
balancedCarve

/*:
 
 This improvement in quality it able to occur while not slowing it down significantly from the fully shared Sobel method.
 
 ![Total time of all](/TotalTimeShared.png)
 
 The unique Sobel is making the scale too small to see the slight difference between the lower three. While that effectively demonstrates how much of an improvement this is performance wide, let's also cut it out to get a better view.
 
 ![Total time of shared, every 25, and every 10](/TotalTimeBalanced.png)
 
 As you can see, this is able to strike a promising middle-ground. While not too large of a difference between unique and shared Sobel here, you will have an opportunity to further explore it on the next page
 
 ## Speed Side Note
 One interesting side-note this profiling revealed this graphs reveals is while it may be expected for those graphs to have a linear slope, they are actually logarithmic.
 
 This can be seen more clearly when the graph is focused on the line of the shared times.
 
 ![Total time of shared function](/TotalTimeShared.png)
 
 While this behavior might seem strange at first, it actually has an intuitive explanation. Each time a seam is calculated and then removed, it has to run on an image of one less width. Since the time complexity of the algorithm is dependent on the size of the image, it causes each sequential seam to be calculated slightly faster.
 
 This relationship can be seen in the graph of the average time spent on each removing individual rows.
 
 ![Time per pixel](/AvgTimePerPixel.png)

 That doesn't have anything to do with the greater project, I just stumbled on that when profiling and thought it was interesting.
 
 That's now all of the content to cover! Next, you'll be able to use an interactive demo to experience the algorithm more in action.
 
 [Next](@next)

 */
