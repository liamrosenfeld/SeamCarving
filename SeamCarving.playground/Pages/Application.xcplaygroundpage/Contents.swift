/*:
 # Application
 
 Now that we have figured out how to remove one seam from the image, we can repeat that process to remove multiple.
 
 ## Implementation
 
 The simplest method of doing so would be just looping the entirety of what removes a single seam. That would be implemented as:
 */

import AppKit

func _carveImage(_ image: CGImage, width: Int) -> CGImage {
    var carvedImage = image
    
    let widthDiff = image.width - width
    for _ in 0..<widthDiff {
        // get sobeled image
        let sobeledImage = sobel(carvedImage)
        let sobeledBuffer  = sobeledImage.planarBuffer
        
        // get sums from sobel
        let (sums, dirs) = edginessSums(buffer: sobeledBuffer)
        sobeledBuffer.free()
        
        // find seam
        let seam = findSeam(edginessSums: sums, directions: dirs)
        var imageMatrix = carvedImage.argbBuffer.argb8ToMatrix()
        
        // apply seam
        removeSeam(seam, from: &imageMatrix)
        
        // turn matrix into image so Sobel filter can be reapplied
        carvedImage = CGImage.argbFromMatrix(imageMatrix)
    }
    
    // reassemble
    let newSize = NSSize(width: carvedImage.width, height: carvedImage.height)
    
    return NSImage(cgImage: carvedImage, size: newSize).cgImage
}

//: Now let's use that to shrink our image a noticeable amount

let image  = ImageFile.get(named: "pom.png").scaledArgbImage()!.cgImage
let carved = carveImage(image, width: 310)

//: Let's compare our carved image to the original

image
carved

/*:
 ## Potential Optimization
 
 The two components of each seam removal which take up the most time are the summing function and the Sobel filter. Over my time working on this project, I have highly optimized the summing function, gradually bringing it down from over 100ms per row removed to 3ms (the git history for that function is quite interesting).
 
 That makes the next obvious target the Sobel filter. Because it runs on the GPU, the Sobel filter is already highly optimized, and clocks in at only around 5ms per application. However, there is a method that greatly reduces the total time spent on the Sobel filter: doing it less.
 
 Currently, the Sobel filter is reapplied every time a row is removed from the image. When there are large gaps between edges in the image, that is not entirely necessary because the edges would not dramatically change between each pass.
 
 The nature of the seam removing function allows for this reuse because its objective is dodging pixels of high value in the Sobel output.
 
 However, on visually busier images, removing a seam might create an area of higher edginess than before, causing the Sobel output to become meaningfully outdated and ultimately leading to more jarring removals.
 
 That Sobel sharing function can be implemented as shown below.
 
 This function utilizes a different summing function which takes in a matrix instead of an image buffer. It is the exact same otherwise (which can be confirmed at `/Sources/Sums.swift`).
 */

func _sharedCarveImage(_ image: CGImage, width: Int) -> CGImage {
    let widthDiff = image.width - width
    
    // get sobeled image
    let sobeledImage = sobel(image)
    let sobeledBuffer = sobeledImage.planarBuffer
    
    // get matrix of both
    var imageMatrix = image.argbBuffer.argb8ToMatrix()
    var sobelMatrix = sobeledBuffer.planarToMatrix()
    sobeledBuffer.free()
    
    for _ in 0..<widthDiff {
        // get sums and seam
        let (sums, dirs) = edginessSums(intensities: sobelMatrix)
        let seam = findSeam(edginessSums: sums, directions: dirs)
        
        // apply seam to both sobel and image
        removeSeam(seam, from: &imageMatrix)
        removeSeam(seam, from: &sobelMatrix)
    }
    
    // reassemble
    let carvedImage = CGImage.argbFromMatrix(imageMatrix)
    let newSize = NSSize(width: width, height: image.height)
    
    return NSImage(cgImage: carvedImage, size: newSize).cgImage
}

// Use our new function
let sharedCarve = sharedCarveImage(image, width: 310)

/*:
 As you can see, the results between shared and unique Sobel is nearly identical in this case.
 However, there are some areas where the shared Sobel method resulted in a sloppier image.
 For example, the new border between the mountain and the sky is more jarring.
 */

carved
sharedCarve

/*:
 The performance of the shared Sobel method vs the unique Sobel method can be seen on this graph.
 
 ![Total Time](/TotalTime.png)
 
 (All graphs generated by using `os_signpost` and Xcode time profiler to get an average time for many runs. It was then plotted in excel.)
 
 This is quite a notable performance improvement.
 
 However, the tradeoff of quality can be seen with the mountains. The border between the mountain and the sky is removable at first because of the manner in which the colors are blended.
 
 However, as those bordering pixels are removed, the transition becomes sharper and sharper. The algorithm is not made aware of that development because the Sobel isn't recalculated.
 
 ## Balancing Optimization with Results
 
 A balance could further be struck by recalculating the Sobel filter after every so many rows are removed. That should allow the formation of new edges, such as with the mountains, to be caught before they become too much of an issue.
 
 That can be implemented as follows:
 */

func _balancedCarveImage(_ image: CGImage, width: Int, sobelPer: Int) -> CGImage {
    let widthDiff = image.width - width
    
    // apply initial sobel
    let sobeledImage = sobel(image)
    let grayscale = sobeledImage.planarBuffer
    
    // get matrixes of orig and sobel
    var imageMatrix = image.argbBuffer.argb8ToMatrix()
    var sobelMatrix = grayscale.planarToMatrix()
    grayscale.free()
    
    for removalNum in 0..<widthDiff {
        // reapply and replace sobel matrix every sobelPer
        if removalNum % sobelPer == 0 {
            let sobeledImage = sobel(CGImage.argbFromMatrix(imageMatrix))
            let grayscale = sobeledImage.planarBuffer
            sobelMatrix = grayscale.planarToMatrix()
        }
        
        // get sum and seam
        let (sums, dirs) = edginessSums(intensities: sobelMatrix)
        let seam = findSeam(edginessSums: sums, directions: dirs)
        
        // apply seam on image and sobel matrix
        removeSeam(seam, from: &imageMatrix)
        removeSeam(seam, from: &sobelMatrix)
    }
    
    // reassemble
    let carvedImage = CGImage.argbFromMatrix(imageMatrix)
    let newSize = NSSize(width: width, height: image.height)
    
    return NSImage(cgImage: carvedImage, size: newSize).cgImage
}

// Use our new function
let balancedCarve = balancedCarveImage(image, width: 310, sobelPer: 10)

//: As you can see, the results between balanced and unique Sobel is even closer.
//: This is especially apparent with return to a curvier mountain side.

carved
sharedCarve
balancedCarve

/*:
 
 The improvement in quality found in the balanced method it able to occur while not still not taking much longer than the fully shared Sobel method.
 
 ![Total time of all](/TotalTimeAll.png)
 
 The unique Sobel is making the scale too small to see the slight difference between the lower three. While that effectively demonstrates how much of an improvement this is in performance, let's also cut it out to get a better view.
 
 ![Total time of shared, every 25, and every 10](/TotalTimeBalanced.png)
 
 As you can see, this is able to strike a promising middle-ground. While not too large of a difference between unique and shared Sobel here, you will have an opportunity to further explore it on the next page
 
 ## Speed Side Note
 One interesting side-note this profiling revealed is while it may be expected for those graphs to have a linear slope, they are actually logarithmic.
 
 This can be seen more clearly when the graph is focused on the line of the shared times.
 
 ![Total time of shared function](/TotalTimeShared.png)
 
 While this behavior might seem strange at first, it has an intuitive explanation. Each time a seam is calculated and then removed, it has to run on an image of one less width. Since the time complexity of the algorithm is dependent on the size of the image, it causes each sequential seam to be calculated slightly faster.
 
 This relationship can be seen in the graph of the average time spent on each removing individual rows.
 
 ![Time per pixel](/AvgTimePerPixel.png)

 While that understanding is not required to understand the code, I feel it is an interesting opportunity to grow one's understanding of how the algorithm functions.
 
 That's all of the content to cover! Next, you'll be able to use an interactive demo to experience the algorithm in action.
 
 [Next](@next)

 */
